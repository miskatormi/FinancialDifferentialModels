import numpy as np

class ODEModel:
    
    def __init__(self, F, params):
        self.RHS = F
        self.params = params
    
    def __str__(self):
        return 'D(Vec[y])=Vec['+str(self.RHS)+']'

class RK4Solve:

    def __init__(self, D : ODEModel, h: float, n : int):
        self.eq = D
        self.tstep = h
        self.nsteps = n
    
    def NextStep(self,t: float ,  x : np.array, params):
        k1 = self.tstep*self.eq.RHS(t, x, params)
        k2 = self.tstep*self.eq.RHS(t + self.tstep/2, x + k1/2, params)
        k3 = self.tstep*self.eq.RHS(t + self.tstep/2, x + k2/2, params)
        k4 = self.tstep*self.eq.RHS(t + self.tstep, x + k3, params)
        return x + (1/6)*(k1 + 2*k2 + 2*k3 + k4)
    
    def solve(self, t : float,x : np.array, paramsarr):
        n1x = np.shape(x)[0]
        time = np.zeros(self.nsteps+1)
        value = np.zeros((n1x,self.nsteps+1))
        value[:,0] = x
        time[0] = t
        for i in range(1,self.nsteps+1):
            value[:,i] = self.NextStep(time[i-1], value[:,i-1], paramsarr[:,i-1])
            time[i] = t + i*self.tstep
        return time, value
        


    
class SDEModel:

    def __init__(self, a, b):
        self.func_dt = a
        self.func_dW = b

    def __str__(self):
        return 'dX_t= ' + str(self.func_dt) + '*dt + ' + str(self.func_dW) + '*dW_t'
    
class EulerMaruyamaMonteCarlo:

    def __init__(self, Model : SDEModel, h : float, n : int):
        self.model = Model
        self.tstep = h
        self.nsteps = n
    
    def NextStepMonteCarlo(self, t : float,x : np.array, params): # x here represents starting point for all separate simulations what we calculate vectorized
        dW_t = np.random.normal(0, np.sqrt(self.tstep), np.shape(x))
        return x + self.model.func_dt(t,x, params)*self.tstep + self.model.func_dW(t,x, params)*dW_t
    
    def Simulate(self, t, x, paramsarr):
        n1x = np.shape(x)[0]
        time = np.zeros(self.nsteps+1)
        value = np.zeros((n1x,self.nsteps+1))
        value[:,0] = x
        time[0] = t
        for i in range(1,self.nsteps+1):
            value[:,i] = self.NextStepMonteCarlo(time[i-1], value[:,i-1], paramsarr[:,i-1])
            time[i] = t + i*self.tstep
        return time, value
    

    
class MonteCarloSummary:

    def __init__(self, times : np.array, value : np.array):
        self.times = times
        self.value = value

    def TimeSeriesSummary(self):
        return {'time': self.times,
                'Mean': np.mean(self.value, axis=0),
                'Median': np.median(self.value, axis=0),
                'StandardDeviation': np.std(self.value, axis=0),
                'Max':np.max(self.value, axis=0),
                'Min':np.min(self.value, axis=0),
                'quantiles': {q : np.quantile(self.value,q, axis=0) for q in [0.05,0.25,0.50,0.75,0.95]}}
    
    def TerminalValue(self):
        return self.value[:,-1]
    
    def RiskSummary(self):
        TerminalReturn = self.value[:,-1]/self.value[0,0]-1
        TerminalLoss = - TerminalReturn
        VaR95 = np.quantile(TerminalLoss, 0.95)
        mask = TerminalLoss >= VaR95
        return {'VaR95' : VaR95, 'CVaR95' : np.mean(TerminalLoss[mask])}
        

         

