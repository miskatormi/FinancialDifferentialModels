import numpy as np
import matplotlib.pyplot as plt

class ODEModel:
    """

    A class modelling an Ordinary Differential Equation of the form D_t(x)=RHS(t, x, params=...). Note here that RHS and x must have same shape!

    ********

    Parameters:

    F : callable (function) (RHS meaning the right hand side of the ODE)

    """
    def __init__(self, F):
        self.RHS = F
    
    def __str__(self):
        return 'dx/dt='+str(self.RHS)

class RK4Solve:
    """ 
    
    Runge-Kutta 4 Solver for the ODEModel class:
    
    ********
    
    Parameters:
    
    D : ODEModel
    an ODE model

    h : float
    size of the time step used in simulation

    n : int
    total number of steps
    
    ********
    
    Methods:
    next_step(t : float, x : np.ndarray, params : np.ndarray) -> np.ndarray : 
    Takes initial values x and time t to give the value x at time t + self.tstep.

    solve(t : float, x : np.ndarray, paramsarr : np.ndarray) -> Tuple[np.ndarray , np.ndarray (with shape: (state_dim, n_steps+1))]  : 
    Takes initial values x and time t to give the full simulated data of all values x at all times t. (paramsarr.shape == (param_dim, n_steps))

    """

    def __init__(self, D : ODEModel, h: float, n : int):
        self.eq = D
        self.tstep = float(h)
        self.nsteps = int(n)
    
    def next_step(self,t: float ,  x : np.ndarray, params : np.ndarray = None): # Returns reliable results for nicely behaving parameters.
        if params is None:
            k1 = self.tstep*self.eq.RHS(t, x)
            k2 = self.tstep*self.eq.RHS(t + self.tstep/2, x + k1/2)
            k3 = self.tstep*self.eq.RHS(t + self.tstep/2, x + k2/2)
            k4 = self.tstep*self.eq.RHS(t + self.tstep, x + k3)
        else:
            k1 = self.tstep*self.eq.RHS(t, x, params)
            k2 = self.tstep*self.eq.RHS(t + self.tstep/2, x + k1/2, params)
            k3 = self.tstep*self.eq.RHS(t + self.tstep/2, x + k2/2, params)
            k4 = self.tstep*self.eq.RHS(t + self.tstep, x + k3, params)
        return x + (1/6)*(k1 + 2*k2 + 2*k3 + k4)
    
    def solve(self, t : float,x : np.ndarray, paramsarr : np.ndarray = None): # Note shape of paramsarr-array!
        x = np.atleast_1d(x).astype(float)
        n1x = np.shape(x)[0]
        time = np.zeros(self.nsteps+1)
        value = np.zeros((n1x,self.nsteps+1))
        value[:,0] = x
        time[0] = t
        if paramsarr is None:
            for i in range(1,self.nsteps+1):
                value[:,i] = self.next_step(time[i-1], value[:,i-1])
                time[i] = t + i*self.tstep
        else:
            for i in range(1,self.nsteps+1):
                value[:,i] = self.next_step(time[i-1], value[:,i-1], paramsarr[:,i-1])
                time[i] = t + i*self.tstep
        return time, value
        


    
class SDEModel:

    """
    
    A class modelling a Stochastic Differential Equation of the form dX_t=a*dt+b*dW_t, where dW_t is normally distributed.

    ********

    Parameters:

    a : callable (function)

    b : callable (function)

    """

    def __init__(self, a, b):
        self.func_dt = a
        self.func_dW = b

    def __str__(self):
        return 'dX_t= ' + str(self.func_dt) + '*dt + ' + str(self.func_dW) + '*dW_t'
    
class EulerMaruyamaMonteCarlo:

    """

    A class that models a simulator to a SDE using the Euler-Maruyama algorithm and the Monte Carlo method.

    ********

    Parameters:

    Model : SDEModel
    The SDE we want to solve

    h : float
    Size of the time step

    n : int
    The total number of steps in the simulation

    ********

    Methods:

    next_step_monte_carlo(t : float, x: np.ndarray, params : np.ndarray) -> np.ndarray : 
    Takes in an array vector x filled with the starting value, the starting time t
    and the parameters array params and return vector of the same shape as x but after
    time self.tstep, each component is a different path of the stochastic process.

    simulate(t : float, x : np.ndarray, paramsarr : np.ndarray) -> Tuple[np.ndarray,np.ndarray (with shape: (paths, n_steps+1))] : 
    Gives all the steps of all paths in the array x and additionally returns the corresponding times t. (paramsarr.shape == (param_dim, n_steps))

    """

    def __init__(self, Model : SDEModel, h : float, n : int):
        self.model = Model
        self.tstep = float(h)
        self.nsteps = int(n)
    
    def next_step_monte_carlo(self, t : float, x : np.ndarray, params : np.ndarray = None):
        dW_t = np.random.normal(0, np.sqrt(self.tstep), np.shape(x))
        if params is None:
            return x + self.model.func_dt(t,x)*self.tstep + self.model.func_dW(t,x)*dW_t
        else:
            return x + self.model.func_dt(t,x, params)*self.tstep + self.model.func_dW(t,x, params)*dW_t
    
    def simulate(self, t : float, x : np.ndarray, paramsarr : np.ndarray = None):
        n1x = np.shape(x)[0]
        time = np.zeros(self.nsteps+1)
        value = np.zeros((n1x,self.nsteps+1))
        value[:,0] = x
        time[0] = t
        if paramsarr is None:
            for i in range(1,self.nsteps+1):
                value[:,i] = self.next_step_monte_carlo(time[i-1], value[:,i-1])
                time[i] = t + i*self.tstep
        else:
            for i in range(1,self.nsteps+1):
                value[:,i] = self.next_step_monte_carlo(time[i-1], value[:,i-1], paramsarr[:,i-1])
                time[i] = t + i*self.tstep
        return time, value
    

    
class MonteCarloSummary:
    """
    
    A class meant to model a data structure which has many stochastic walks in some time interval.

    ********

    Parameters:
    
    times : np.ndarray
    The time data points on the wanted interval.

    value : np.ndarray
    The row vectors contain the different walks/paths of the stochastic process.

    ********

    Methods:

    time_series_summary() -> dict
    Calculates most statistics for each time step of the different paths.

    terminal_value() -> np.ndarray
    Returns the last column vector, practically giving the distribution of the random variable that we want to solve

    risk_summary -> dict
    Returns values of VaR95, CVaR95

    """

    def __init__(self, times : np.ndarray, value : np.ndarray):
        self.times = times
        self.value = value

    def time_series_summary(self):
        return {'time': self.times,
                'Mean': np.mean(self.value, axis=0),
                'Median': np.median(self.value, axis=0),
                'StandardDeviation': np.std(self.value, axis=0),
                'Max':np.max(self.value, axis=0),
                'Min':np.min(self.value, axis=0),
                'quantiles': {q : np.quantile(self.value,q, axis=0) for q in [0.05,0.25,0.50,0.75,0.95]}}
    
    def terminal_value(self):
        return self.value[:,-1]
    
    def risk_summary(self):
        TerminalReturn = self.value[:,-1]/self.value[0,0]-1 #Assumes that all paths have same start point!
        TerminalLoss = - TerminalReturn
        VaR95 = np.quantile(TerminalLoss, 0.95)
        mask = TerminalLoss >= VaR95
        return {'VaR95' : VaR95, 'CVaR95' : np.mean(TerminalLoss[mask])}

class SensitivitySDEAnalysisTool():
    """
    
    A class that models a simple sensitivity analysis tool.

    ********

    Parameters:

    SModel : EulerMaruyamaMonteCarlo
    The solver of the SDE we are inspecting

    percentage : float
    How much you want to add to the paramater

    paramspecifier : int
    Which parameter you want to change

    ********

    Methods:

    tell_new_result(t : float, x : np.ndarray, paramsarr : np.ndarray) -> Tuple[np.ndarray, np.ndarray]
    Returns the result of the simulation using the new parameters.

    tell_new_result_summaries(t : float, x : np.ndarray, paramsarr : np.ndarray) -> Tuple[dict, np.ndarray, dict]
    Returns all possible statistics using the MonteCarloSummary class of the new simulated values.
    
    
    """
    def __init__(self, SModel : EulerMaruyamaMonteCarlo, percentage : float, paramspecifier : int):
        self.SolModel = SModel
        self.coeff = percentage/100+1
        self.param = int(paramspecifier)

    def tell_new_result(self, t : float, x : np.ndarray, paramsarr : np.ndarray):
        new_params = paramsarr.copy()
        new_params[self.param] *= self.coeff
        return self.SolModel.simulate(t,x,new_params)
    
    def tell_new_result_summaries(self, t : float, x : np.ndarray, paramsarr : np.ndarray):
        new_params = paramsarr.copy()
        new_params[self.param] *= self.coeff
        time, value = self.SolModel.simulate(t,x,new_params)
        summaryNew = MonteCarloSummary(time,value)
        return summaryNew.risk_summary(), summaryNew.terminal_value(), summaryNew.time_series_summary()
    
    #def two_param_heatmap(self, t : float, x : np.ndarray, paramsarr : np.ndarray, min : float, max : float): # Assumes that paramsarr shape is (2,1)!

def f(t,x):
    return t*2

def g(t,x):
    return t

basic = SDEModel(f,g)
solver = EulerMaruyamaMonteCarlo(basic, 0.01, 100)
time, value = solver.simulate(0,np.full(100,0))
summary = MonteCarloSummary(time, value)
a = summary.time_series_summary()
print(summary.time_series_summary())
for i in range(100):
    plt.plot(time,value[i,:], 'k')

plt.plot(a['time'],a['StandardDeviation'])
plt.plot(a['time'],a['Mean'])
plt.plot(a['time'],a['Max'])

plt.show()